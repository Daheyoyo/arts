# ***Algorithm***
## ***Two Sum***
### Description
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

### Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
### My Solution In Java
```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        for(int i=0;i<nums.length;i++){
            for(int j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j] == target){
                    res[0] = i;
                    res[1] = j;
                    return res;
                }
            }
        }
        throw new RuntimeException("no suitable elements for given target!");
    }
}
```
### Analyse
my solution is simple,exactly same idea with [Approach 1: Brute Force] in  the [Solution Tab] given by leecode,just loop through each element xx and find if there is another value that equals to (target-x).
I found that there are more effiective ways to solve this problem by introducing a hash table, the hash table maintains a mapping of each element in the array to its index,which can reduce the look up time from O(n) to O(1) by trading space for speed.Here is the code,which is more effictive than my solution,especialy when the array is large.
```
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```
# ***Review***
### ***Original Artical：本周Review的材料来自来自耗叔在《程序员练级攻略（2018）：分布式架构经典图书和论文》中推荐的英文书籍<Designing Data-Intensive Applications>中的PART I：Foundations of Data Systems >> Chapter I Reliable, Scalable, and
Maintainable Applications
### ***My Review***
这部分的内容在纸质书上一共25页，PDF上一共47页，内容比较简单，相大家只要接触过各种各样的数据存储引擎的都很容易理解。主要就是给全书后面的内容做一个铺垫，我简单总结一下。
当今世界的很多应用都是数据密集型，CPU的性能很少成为瓶颈，反而是大数据量，数据的复杂性和数据变化的速率会引起很多问题。
一个数据密集型的应用通常是为了提供一些目前比较常用的功能，通过一些比较标准的构建模式构建起来的，比如现在很多应用都需要以下几个特点:
```
• 存储数据，以便后续查找 (数据库)
• 记住一些耗时操作的结果，以便下次可以加快查询 (缓存)
• 允许用户通过关键字进行检索或者各种各样的过滤 (搜索引擎)
• 发送消息给另外的进程异步处理 (流式处理)
• 阶段性的对大数据量进行计算 (批处理)
```
由于不同的应用对数据存储有着不同的需求，所以产生了现代的各种各种的有着不同特性的数据存储系统，各式缓存策略，不同的建索引的方式等等。
在构建应用时我们就要想清楚该采用哪种工具哪种策略最合适，有的时候一种工具无法满足需求时可能还得结合各种工具一起使用。
这本书后面的内容就是围绕各种数据存储系统的优缺点，共同点，有哪些地方导致它们有这些差异的，以及如何实现它们各自的特性的等等这些地方进行讨论。
这一章节主要就是讨论这些各式各样的数据存储系统要实现的最基本的目标：可靠的、可伸缩的和可维护的数据存储系统。我们集中讨论软件系统的最重要的三个关注点：
Reliability(可靠性)
系统即使在出现硬件错误、软件错误或者人为错误的情况下也应该持续运行正常，在预期的性能下执行正确的功能。一般来说系统只要达到了以下几点就可以说是可靠的：
• 正确执行了功能，返回预期的结果
• 可以容错（硬件错误、软件错误或者人为错误）
• 满足在预期的负载和数据体量下的的性能要求
• 阻止未授权的访问和滥用

Scalability（可伸缩性）
随着系统数据体量、数据传输体量以及数据复杂度的增加，负载也会随之增加，应该有合理的方式来处理这些增长。
如何描述负载？
能够用来描述增长的因素叫做负载因子，根据系统架构的不同有着不同的最佳负载因子来描述系统增长，有可能是每秒用户请求数，数据库读写频率，聊天室同时在线人数，缓存命中率等等
用推特的案例来描述：在每个用户登录推特主页时，主页要展示他们关注的人在一段时间的推特信息流，技术团队早期的实现方式是在用户请求个人主页信息流时才去查询这些信息流，很艰难地维持这些查询的负载，特别是对于一些名人有着非常多的follower（千万级别）的情况
后面换成了预先计算的方式（提前把每个用户主页信息流统计好然后存储在每个用户的缓存中，类似于邮件收件箱一样的方式）之后，效果就好了很多，因为用户发推的频率（写）比用户查看推特信息流（读）的频率少两个数量级。因此，每个用户的follower的分布情况是非常重要的一个用于描述负载的因子，对于有着大量粉丝名人的推特情况还得单独处理。
如何描述性能？
一旦确定了如何描述系统负载，那么你可以观察当负载因子的值增大后会出现什么情况。可以有两个角度来观察，
当系统资源（CPU，内存，网络带宽等）固定时，增大负载因子的值，系统性能是否有影响？
当增加负载因子的值后，要保持系统性能不受影响，需要增加多少系统资源？
以上两个问题都需要依据性能指标，在hadoop这样的批处理系统中我们一般关心系统吞吐量——每秒处理的记录数，或者特定数据量下一个任务运行的总时间，一般的线上系统我们关心服务的响应时间。一个同样的请求我们反复请求，每次的响应时间都可能不一样，造成不一样的原因有很多，进程/线程上下文切换、网络丢包导致TCP协议重传、垃圾回收处理机制、缺页异常导致从读磁盘、服务器机架共振等等都有可能导致随机的延时。
因此在实际中，由于系统同时在处理各种各样的请求，因此响应时间很可能在某一个范围波动，所以我们不应该只关心响应时间这么一个数字，而是响应时间的范围分布，
时间范围的指标可以由算术平均值来描述，当然有时我们关心系统典型的响应时间，平均值就不是一个很好的度量，它没法反应大多数用户的体验。
最好是通过百分位数来表示，通过百分位数更能直观的了解用户的体验情况，比如50%的点是一个中位数，如果中位数的响应时间是200ms，那么说明一半的请求小于200ms，另一半请求超过200ms。
另外，通过百分位数也能更找到那些异常点（outliers），通过查看高百分位数比如p95, p99, and p999的响应，可以知道系统中有多少请求快过在极限情况下的响应，如果p95是1.5s，那么100个请求中有95个请求是小于1.5s的。
对于这些高百分位数区间的响应时间，一般是由于队列延迟（queueing delays）导致的，一个服务器由于受到CPU核数的限制，只能同时并行处理小部分的工作。当一些慢响应的请求占据了CPU资源，阻挡服务器接受随后的请求时，就出现了所谓的头部队列阻塞（head-of-line blocking）效应，即使这些小请求处理起来很快，也要等待之前的请求处理完成，所以在客户端看起来，这些本来很快处理完成的小请求也变得很慢。
因此在人工压测的时候需要模拟这样的场景，通过调整各种度量来缩短等待队列的长度。
另外一种情况也会导致响应时间慢，当需要某几个后台终端调用来处理一个用户请求时，一个很慢的后台终端请求会拖慢整个请求。




Maintainability（可持续维护性）
随着时间推移，有各种各样的人来在系统上做一些操作，系统应该便于维护。
# ***Tip***
I tried to insert some  data to Oracle database through JDBC last week,I use the MYSQL jdbc driver in my code by mistake,the driver jar and the driver name was related to  MYSQL,not Oracle.
Surprisingly,the code with the wrong driver worked fine with the CRUD action!I googled on the Internet found no such case as mine.I think I can only figured out the reason after I read the orginal code of mysql jdbc driver and the oracle jdbc driver.
# ***Share***
Last week I was preparing a technology sharing in my company.It's about an OLAP Engine for big data called Apache Kylin.I recorded my sharing procedure  serval times after work after the sharing,finally,a 104 minutes' video sharing was done.I uploaded the recorded video to baiduyunpan, Here is the video made by myself,making it public so that anyone interested in this can feel free to watch and download it.Any questions about this sharing are invited.

My video sharing of  Apache Kylin :https://pan.baidu.com/s/1q0LIZntXdynFGSLWKvBGDg


